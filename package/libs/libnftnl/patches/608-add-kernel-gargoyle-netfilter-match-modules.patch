--- /dev/null	2025-12-08 14:44:46.335265239 +0800
+++ libnftnl.new/src/expr/webmon.c	2025-12-08 20:00:44.986655194 +0800
@@ -0,0 +1,323 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/netfilter/nf_tables.h>
+#include <linux/netfilter/webmon.h>
+
+#include <time.h>
+#include <sys/time.h>
+
+#include "internal.h"
+#include <libmnl/libmnl.h>
+#include <libnftnl/expr.h>
+#include <libnftnl/rule.h>
+
+struct nftnl_expr_webmon {
+	uint32_t		flags;
+	uint32_t		max_domains;
+	uint32_t		max_searches;
+	const char		*ips;
+	const char		*domain_load_file;
+	const char		*search_load_file;
+};
+
+static unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length)
+{
+	int max_read_size = read_block_size;
+	unsigned char* read_string = (unsigned char*)malloc(max_read_size+1);
+	unsigned long bytes_read = 0;
+	int end_found = 0;
+	while(end_found == 0)
+	{
+		int nextch = '?';
+		while(nextch != EOF && bytes_read < max_read_size)
+		{
+			nextch = fgetc(in);
+			if(nextch != EOF)
+			{
+				read_string[bytes_read] = (unsigned char)nextch;
+				bytes_read++;
+			}
+		}
+		read_string[bytes_read] = '\0';
+		end_found = (nextch == EOF) ? 1 : 0;
+		if(end_found == 0)
+		{
+			unsigned char *new_str;
+			max_read_size = max_read_size + read_block_size;
+		       	new_str = (unsigned char*)malloc(max_read_size+1);
+			memcpy(new_str, read_string, bytes_read);
+			free(read_string);
+			read_string = new_str;
+		}
+	}
+	*length = bytes_read;
+	return read_string;
+}
+
+static unsigned char* do_load(char* file, uint32_t max, unsigned char type, uint32_t* data_len)
+{
+   unsigned char* data = NULL;
+	if(file != NULL)
+	{
+		unsigned long data_length = 0;
+		char* file_data = NULL;
+		if(strcmp(file, "/dev/null") != 0)
+		{
+			FILE* in = fopen(file, "r");
+			if(in != NULL)
+			{
+				file_data = (char*)read_entire_file(in, 4096, &data_length);
+				fclose(in);
+			}
+		}
+		if(file_data == NULL)
+		{
+			file_data=strdup("");
+		}
+
+		if(file_data != NULL)
+		{
+			data_length = strlen(file_data) + sizeof(uint32_t)+2;
+			data = (unsigned char*)malloc(data_length);
+			if(data != NULL)
+			{
+				uint32_t* maxp = (uint32_t*)(data+1);
+				data[0] = type;
+				*maxp = max;
+				sprintf( (data+1+sizeof(uint32_t)),  "%s", file_data);
+               *data_len = data_length;
+			}
+			free(file_data);
+		}
+	}
+   return data;
+}
+
+static int nftnl_expr_webmon_set(struct nftnl_expr *e, uint16_t type,
+				 const void *data, uint32_t data_len)
+{
+	struct nftnl_expr_webmon *webmon = nftnl_expr_data(e);
+	switch(type){
+	case NFTNL_EXPR_WEBMON_FLAGS:
+		memcpy(&webmon->flags, data, data_len);
+		break;
+	case NFTNL_EXPR_WEBMON_MAXDOMAINS:
+		memcpy(&webmon->max_domains, data, data_len);
+		break;
+	case NFTNL_EXPR_WEBMON_MAXSEARCHES:
+		memcpy(&webmon->max_searches, data, data_len);
+		break;
+	case NFTNL_EXPR_WEBMON_IPS:
+		webmon->ips = strdup(data);
+		if (!webmon->ips)
+			return -1;
+		break;
+	case NFTNL_EXPR_WEBMON_DOMAINLOADFILE:
+		webmon->domain_load_file = strdup(data);
+		if (!webmon->domain_load_file)
+			return -1;
+		break;
+	case NFTNL_EXPR_WEBMON_SEARCHLOADFILE:
+		webmon->search_load_file = strdup(data);
+		if (!webmon->search_load_file)
+			return -1;
+		break;
+	}
+	return 0;
+}
+
+static const void *
+nftnl_expr_webmon_get(const struct nftnl_expr *e, uint16_t type,
+		      uint32_t *data_len)
+{
+	struct nftnl_expr_webmon *webmon = nftnl_expr_data(e);
+
+	switch(type) {
+	case NFTNL_EXPR_WEBMON_FLAGS:
+		*data_len = sizeof(uint32_t);
+		return &webmon->flags;
+	case NFTNL_EXPR_WEBMON_MAXDOMAINS:
+		*data_len = sizeof(uint32_t);
+		return &webmon->max_domains;
+	case NFTNL_EXPR_WEBMON_MAXSEARCHES:
+		*data_len = sizeof(uint32_t);
+		return &webmon->max_searches;
+	case NFTNL_EXPR_WEBMON_IPS:
+		*data_len = strlen(webmon->ips)+1;
+		return webmon->ips;
+	case NFTNL_EXPR_WEBMON_DOMAINLOADFILE:
+		*data_len = strlen(webmon->domain_load_file)+1;
+		return webmon->domain_load_file;
+	case NFTNL_EXPR_WEBMON_SEARCHLOADFILE:
+		*data_len = strlen(webmon->search_load_file)+1;
+		return webmon->search_load_file;
+	}
+	return NULL;
+}
+
+static int nftnl_expr_webmon_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, NFTA_WEBMON_MAX) < 0)
+		return MNL_CB_OK;
+
+	switch(type) {
+	case NFTNL_EXPR_WEBMON_FLAGS:
+	case NFTNL_EXPR_WEBMON_MAXDOMAINS:
+	case NFTNL_EXPR_WEBMON_MAXSEARCHES:
+		if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0)
+			abi_breakage();
+		break;
+	case NFTNL_EXPR_WEBMON_IPS:
+	case NFTNL_EXPR_WEBMON_DOMAINLOADFILE:
+	case NFTNL_EXPR_WEBMON_SEARCHLOADFILE:
+	case NFTNL_EXPR_WEBMON_DOMAINLOADDATA:
+	case NFTNL_EXPR_WEBMON_SEARCHLOADDATA:
+		if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0)
+			abi_breakage();
+		break;
+	}
+
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static void
+nftnl_expr_webmon_build(struct nlmsghdr *nlh, const struct nftnl_expr *e)
+{
+	struct nftnl_expr_webmon *webmon = nftnl_expr_data(e);
+
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_FLAGS))
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_WEBMON_FLAGS, htonl(webmon->flags));
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_MAXDOMAINS))
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_WEBMON_MAXDOMAINS, htonl(webmon->max_domains));
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_MAXSEARCHES))
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_WEBMON_MAXSEARCHES, htonl(webmon->max_searches));
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_IPS))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_WEBMON_IPS, webmon->ips);
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_DOMAINLOADFILE))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_WEBMON_DOMAINLOADFILE, webmon->domain_load_file);
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_SEARCHLOADFILE))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_WEBMON_SEARCHLOADFILE, webmon->search_load_file);
+
+	if(webmon->domain_load_file != NULL)
+	{
+		uint32_t data_len = 0;
+		char* domain_data = do_load(webmon->domain_load_file, webmon->max_domains, WEBMON_DOMAIN, &data_len);
+		mnl_attr_put(nlh, NFTNL_EXPR_WEBMON_DOMAINLOADDATA, data_len, domain_data);
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_WEBMON_DOMAINLOADDATALEN, htonl(data_len));
+		if(domain_data != NULL) free(domain_data);
+	}
+	if(webmon->search_load_file != NULL)
+	{
+		uint32_t data_len = 0;
+		char* search_data = do_load(webmon->search_load_file, webmon->max_searches, WEBMON_SEARCH, &data_len);
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_WEBMON_SEARCHLOADDATA, search_data);
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_WEBMON_SEARCHLOADDATALEN, htonl(data_len));
+		if(search_data != NULL) free(search_data);
+	}
+}
+
+static int
+nftnl_expr_webmon_parse(struct nftnl_expr *e, struct nlattr *attr)
+{
+	struct nftnl_expr_webmon *webmon = nftnl_expr_data(e);
+	struct nlattr *tb[NFTA_WEBMON_MAX+1] = {};
+
+	if (mnl_attr_parse_nested(attr, nftnl_expr_webmon_cb, tb) < 0)
+		return -1;
+
+	if (tb[NFTA_WEBMON_FLAGS]) {
+		webmon->flags = ntohl(mnl_attr_get_u32(tb[NFTA_WEBMON_FLAGS]));
+		e->flags |= (1 << NFTA_WEBMON_FLAGS);
+	}
+	if (tb[NFTA_WEBMON_MAXDOMAINS]) {
+		webmon->max_domains = ntohl(mnl_attr_get_u32(tb[NFTA_WEBMON_MAXDOMAINS]));
+		e->flags |= (1 << NFTA_WEBMON_MAXDOMAINS);
+	}
+	if (tb[NFTA_WEBMON_MAXSEARCHES]) {
+		webmon->max_searches = ntohl(mnl_attr_get_u32(tb[NFTA_WEBMON_MAXSEARCHES]));
+		e->flags |= (1 << NFTA_WEBMON_MAXSEARCHES);
+	}
+	if (tb[NFTA_WEBMON_IPS]) {
+		if (webmon->ips)
+			xfree(webmon->ips);
+
+		webmon->ips = strdup(mnl_attr_get_str(tb[NFTA_WEBMON_IPS]));
+		if (!webmon->ips)
+			return -1;
+		e->flags |= (1 << NFTA_WEBMON_IPS);
+	}
+	if (tb[NFTA_WEBMON_DOMAINLOADFILE]) {
+		if (webmon->domain_load_file)
+			xfree(webmon->domain_load_file);
+
+		webmon->domain_load_file = strdup(mnl_attr_get_str(tb[NFTA_WEBMON_DOMAINLOADFILE]));
+		if (!webmon->domain_load_file)
+			return -1;
+		e->flags |= (1 << NFTA_WEBMON_DOMAINLOADFILE);
+	}
+	if (tb[NFTA_WEBMON_SEARCHLOADFILE]) {
+		if (webmon->search_load_file)
+			xfree(webmon->search_load_file);
+
+		webmon->search_load_file = strdup(mnl_attr_get_str(tb[NFTA_WEBMON_SEARCHLOADFILE]));
+		if (!webmon->search_load_file)
+			return -1;
+		e->flags |= (1 << NFTA_WEBMON_SEARCHLOADFILE);
+	}
+
+	return 0;
+}
+
+static int
+nftnl_expr_webmon_snprintf(char *buf, size_t len,
+			   uint32_t flags, const struct nftnl_expr *e)
+{
+	struct nftnl_expr_webmon *webmon = nftnl_expr_data(e);
+	int ret, offset = 0, remain = len;
+
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_FLAGS)) {
+		if(webmon->flags & NFT_WEBMON_F_EXCLUDE || webmon->flags & NFT_WEBMON_F_INCLUDE)
+		{
+			ret = snprintf(buf + offset, remain, "%s-ips %s ", (webmon->flags & NFT_WEBMON_F_EXCLUDE ? "exclude" : "include"), webmon->ips);
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+	}
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_MAXDOMAINS)) {
+		ret = snprintf(buf + offset, remain, "max-domains %u ", webmon->max_domains);
+		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+	}
+	if (e->flags & (1 << NFTNL_EXPR_WEBMON_MAXSEARCHES)) {
+		ret = snprintf(buf + offset, remain, "max-searches %u ", webmon->max_searches);
+		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+	}
+
+	return offset;
+}
+
+static void nftnl_expr_webmon_free(const struct nftnl_expr *e)
+{
+	struct nftnl_expr_webmon *webmon = nftnl_expr_data(e);
+
+	xfree(webmon->ips);
+	xfree(webmon->domain_load_file);
+	xfree(webmon->search_load_file);
+}
+
+struct expr_ops expr_ops_webmon = {
+	.name		= "webmon",
+	.alloc_len	= sizeof(struct nftnl_expr_webmon),
+	.nftnl_max_attr	= NFTA_WEBMON_MAX,
+	.free		= nftnl_expr_webmon_free,
+	.set		= nftnl_expr_webmon_set,
+	.get		= nftnl_expr_webmon_get,
+	.parse		= nftnl_expr_webmon_parse,
+	.build		= nftnl_expr_webmon_build,
+	.output	= nftnl_expr_webmon_snprintf,
+};
\ 文件末尾没有换行符
--- /dev/null	2025-12-08 14:44:46.335265239 +0800
+++ libnftnl.new/src/expr/timerange.c	2025-12-08 20:00:46.170465940 +0800
@@ -0,0 +1,281 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/netfilter/nf_tables.h>
+#include <linux/netfilter/timerange.h>
+
+#include <time.h>
+#include <sys/time.h>
+#include <sys/syscall.h>
+
+#include "internal.h"
+#include <libmnl/libmnl.h>
+#include <libnftnl/expr.h>
+#include <libnftnl/rule.h>
+
+static void set_kernel_timezone(void);
+
+struct nftnl_expr_timerange {
+	uint32_t		flags;
+	const char		*hours;
+	const char		*weekdays;
+	const char		*weeklyranges;
+};
+
+static int nftnl_expr_timerange_set(struct nftnl_expr *e, uint16_t type,
+				 const void *data, uint32_t data_len)
+{
+	struct nftnl_expr_timerange *timerange = nftnl_expr_data(e);
+	switch(type){
+	case NFTNL_EXPR_TIMERANGE_FLAGS:
+		memcpy(&timerange->flags, data, data_len);
+		break;
+	case NFTNL_EXPR_TIMERANGE_HOURS:
+		timerange->hours = strdup(data);
+		if (!timerange->hours)
+			return -1;
+		break;
+	case NFTNL_EXPR_TIMERANGE_WEEKDAYS:
+		timerange->weekdays = strdup(data);
+		if (!timerange->weekdays)
+			return -1;
+		break;
+	case NFTNL_EXPR_TIMERANGE_WEEKLYRANGES:
+		timerange->weeklyranges = strdup(data);
+		if (!timerange->weeklyranges)
+			return -1;
+		break;
+	}
+	return 0;
+}
+
+static const void *
+nftnl_expr_timerange_get(const struct nftnl_expr *e, uint16_t type,
+		      uint32_t *data_len)
+{
+	struct nftnl_expr_timerange *timerange = nftnl_expr_data(e);
+
+	switch(type) {
+	case NFTNL_EXPR_TIMERANGE_FLAGS:
+		*data_len = sizeof(uint32_t);
+		return &timerange->flags;
+	case NFTNL_EXPR_TIMERANGE_HOURS:
+		*data_len = strlen(timerange->hours)+1;
+		return timerange->hours;
+	case NFTNL_EXPR_TIMERANGE_WEEKDAYS:
+		*data_len = strlen(timerange->weekdays)+1;
+		return timerange->weekdays;
+	case NFTNL_EXPR_TIMERANGE_WEEKLYRANGES:
+		*data_len = strlen(timerange->weeklyranges)+1;
+		return timerange->weeklyranges;
+	}
+	return NULL;
+}
+
+static int nftnl_expr_timerange_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, NFTA_TIMERANGE_MAX) < 0)
+		return MNL_CB_OK;
+
+	switch(type) {
+	case NFTNL_EXPR_TIMERANGE_FLAGS:
+		if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0)
+			abi_breakage();
+		break;
+	case NFTNL_EXPR_TIMERANGE_HOURS:
+	case NFTNL_EXPR_TIMERANGE_WEEKDAYS:
+	case NFTNL_EXPR_TIMERANGE_WEEKLYRANGES:
+		if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0)
+			abi_breakage();
+		break;
+	}
+
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static void
+nftnl_expr_timerange_build(struct nlmsghdr *nlh, const struct nftnl_expr *e)
+{
+	struct nftnl_expr_timerange *timerange = nftnl_expr_data(e);
+
+	if (e->flags & (1 << NFTNL_EXPR_TIMERANGE_FLAGS))
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_TIMERANGE_FLAGS, htonl(timerange->flags));
+	if (e->flags & (1 << NFTNL_EXPR_TIMERANGE_HOURS))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_TIMERANGE_HOURS, timerange->hours);
+	if (e->flags & (1 << NFTNL_EXPR_TIMERANGE_WEEKDAYS))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_TIMERANGE_WEEKDAYS, timerange->weekdays);
+	if (e->flags & (1 << NFTNL_EXPR_TIMERANGE_WEEKLYRANGES))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_TIMERANGE_WEEKLYRANGES, timerange->weeklyranges);
+
+	set_kernel_timezone();
+}
+
+static int
+nftnl_expr_timerange_parse(struct nftnl_expr *e, struct nlattr *attr)
+{
+	struct nftnl_expr_timerange *timerange = nftnl_expr_data(e);
+	struct nlattr *tb[NFTA_TIMERANGE_MAX+1] = {};
+
+	if (mnl_attr_parse_nested(attr, nftnl_expr_timerange_cb, tb) < 0)
+		return -1;
+
+	if (tb[NFTNL_EXPR_TIMERANGE_FLAGS]) {
+		timerange->flags = ntohl(mnl_attr_get_u32(tb[NFTNL_EXPR_TIMERANGE_FLAGS]));
+		e->flags |= (1 << NFTNL_EXPR_TIMERANGE_FLAGS);
+	}
+	if (tb[NFTNL_EXPR_TIMERANGE_HOURS]) {
+		if (timerange->hours)
+			xfree(timerange->hours);
+
+		timerange->hours = strdup(mnl_attr_get_str(tb[NFTNL_EXPR_TIMERANGE_HOURS]));
+		if (!timerange->hours)
+			return -1;
+		e->flags |= (1 << NFTNL_EXPR_TIMERANGE_HOURS);
+	}
+	if (tb[NFTNL_EXPR_TIMERANGE_WEEKDAYS]) {
+		if (timerange->weekdays)
+			xfree(timerange->weekdays);
+
+		timerange->weekdays = strdup(mnl_attr_get_str(tb[NFTNL_EXPR_TIMERANGE_WEEKDAYS]));
+		if (!timerange->weekdays)
+			return -1;
+		e->flags |= (1 << NFTNL_EXPR_TIMERANGE_WEEKDAYS);
+	}
+	if (tb[NFTNL_EXPR_TIMERANGE_WEEKLYRANGES]) {
+		if (timerange->weeklyranges)
+			xfree(timerange->weeklyranges);
+
+		timerange->weeklyranges = strdup(mnl_attr_get_str(tb[NFTNL_EXPR_TIMERANGE_WEEKLYRANGES]));
+		if (!timerange->weeklyranges)
+			return -1;
+		e->flags |= (1 << NFTNL_EXPR_TIMERANGE_WEEKLYRANGES);
+	}
+
+	return 0;
+}
+
+static int
+nftnl_expr_timerange_snprintf(char *buf, size_t len,
+			   uint32_t flags, const struct nftnl_expr *e)
+{
+	struct nftnl_expr_timerange *timerange = nftnl_expr_data(e);
+	int ret, offset = 0, remain = len;
+
+	if (e->flags & (1 << NFTNL_EXPR_TIMERANGE_FLAGS)) {
+		bool inv = timerange->flags & NFT_TIMERANGE_F_INV;
+		if(inv)
+		{
+			ret = snprintf(buf + offset, remain, "!= ");
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+	}
+	if (e->flags & (1 << NFTNL_EXPR_TIMERANGE_HOURS)) {
+		ret = snprintf(buf + offset, remain, "hours %s ", timerange->hours);
+		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+	}
+	if (e->flags & (1 << NFTNL_EXPR_TIMERANGE_WEEKDAYS)) {
+		ret = snprintf(buf + offset, remain, "weekdays %s ", timerange->weekdays);
+		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+	}
+	if (e->flags & (1 << NFTNL_EXPR_TIMERANGE_WEEKLYRANGES)) {
+		ret = snprintf(buf + offset, remain, "weeklyranges %s ", timerange->weeklyranges);
+		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+	}
+
+	return offset;
+}
+
+static void nftnl_expr_timerange_free(const struct nftnl_expr *e)
+{
+	struct nftnl_expr_timerange *timerange = nftnl_expr_data(e);
+
+	xfree(timerange->hours);
+	xfree(timerange->weekdays);
+	xfree(timerange->weeklyranges);
+}
+
+struct expr_ops expr_ops_timerange = {
+	.name		= "timerange",
+	.alloc_len	= sizeof(struct nftnl_expr_timerange),
+	.nftnl_max_attr	= NFTA_TIMERANGE_MAX,
+	.free		= nftnl_expr_timerange_free,
+	.set		= nftnl_expr_timerange_set,
+	.get		= nftnl_expr_timerange_get,
+	.parse		= nftnl_expr_timerange_parse,
+	.build		= nftnl_expr_timerange_build,
+	.output	= nftnl_expr_timerange_snprintf,
+};
+
+#ifndef SYS_settimeofday
+# ifdef __NR_settimeofday
+#  define SYS_settimeofday	__NR_settimeofday
+# elif defined(__NR_settimeofday_time32)
+#  define SYS_settimeofday	__NR_settimeofday_time32
+# endif
+#endif
+
+#ifndef SYS_gettimeofday
+# ifdef __NR_gettimeofday
+#  define SYS_gettimeofday	__NR_gettimeofday
+# elif defined(__NR_gettimeofday_time32)
+#  define SYS_gettimeofday	__NR_gettimeofday_time32
+# endif
+#endif
+
+static void set_kernel_timezone(void)
+{
+	time_t now;
+	struct tm* utc_info;
+	struct tm* tz_info;
+	int utc_day;
+	int utc_hour;
+	int utc_minute;
+	int tz_day;
+	int tz_hour;
+	int tz_minute;
+	int minuteswest;
+
+	struct timeval tv;
+	struct timezone old_tz;
+	struct timezone new_tz;
+
+	time(&now);
+	utc_info = gmtime(&now);
+	utc_day = utc_info->tm_mday;
+	utc_hour = utc_info->tm_hour;
+	utc_minute = utc_info->tm_min;
+	tz_info = localtime(&now);
+	tz_day = tz_info->tm_mday;
+	tz_hour = tz_info->tm_hour;
+	tz_minute = tz_info->tm_min;
+
+	utc_day = utc_day < tz_day  - 1 ? tz_day  + 1 : utc_day;
+	tz_day =  tz_day  < utc_day - 1 ? utc_day + 1 : tz_day;
+
+	minuteswest = (24*60*utc_day + 60*utc_hour + utc_minute) - (24*60*tz_day + 60*tz_hour + tz_minute) ;
+	new_tz.tz_minuteswest = minuteswest;
+	new_tz.tz_dsttime = 0;
+
+	/* Get tv to pass to settimeofday(2) to be sure we avoid hour-sized warp */
+	/* (see gettimeofday(2) man page, or /usr/src/linux/kernel/time.c) */
+#ifdef SYS_gettimeofday
+	errno = 0;
+	syscall(SYS_gettimeofday, &tv, &old_tz);
+#else
+	gettimeofday(&tv, &new_tz);
+#endif
+	//printf("set_kernel_timezone: old minuteswest: %d, new minuteswest: %d\n", old_tz.tz_minuteswest, new_tz.tz_minuteswest);
+	/* set timezone */
+#ifdef SYS_settimeofday
+	errno = 0;
+	syscall(SYS_settimeofday, NULL, &new_tz);
+#else
+	settimeofday(NULL, &new_tz);
+#endif
+}
\ 文件末尾没有换行符
--- /dev/null	2025-12-08 14:44:46.335265239 +0800
+++ libnftnl.new/src/expr/bandwidth.c	2025-12-08 20:00:47.393170938 +0800
@@ -0,0 +1,539 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/netfilter/nf_tables.h>
+#include <linux/netfilter/bandwidth.h>
+
+#include <time.h>
+#include <sys/time.h>
+#include <sys/syscall.h>
+
+#include "internal.h"
+#include <libmnl/libmnl.h>
+#include <libnftnl/expr.h>
+#include <libnftnl/rule.h>
+
+struct nftnl_expr_bandwidth {
+	const char* id;
+	uint8_t cmp;
+	uint8_t type;
+	uint8_t check_type;
+	uint64_t bandwidth_cutoff;
+	uint64_t current_bandwidth;
+	const char* subnet;
+	const char* subnet6;
+	uint64_t reset_interval;
+	uint8_t reset_is_constant_interval;
+	uint64_t reset_time;
+	uint64_t next_reset;
+	uint64_t prev_reset;
+	uint32_t num_intervals_to_save;
+	uint64_t last_backup_time;
+	uint32_t minutes_west;
+};
+
+int get_minutes_west(void);
+void set_kernel_timezone(void);
+
+static int nftnl_expr_bandwidth_set(struct nftnl_expr *e, uint16_t type,
+				 const void *data, uint32_t data_len)
+{
+	struct nftnl_expr_bandwidth *bandwidth = nftnl_expr_data(e);
+	switch(type){
+	case NFTNL_EXPR_BANDWIDTH_ID:
+		bandwidth->id = strdup(data);
+		if (!bandwidth->id)
+			return -1;
+		break;
+	case NFTNL_EXPR_BANDWIDTH_CMP:
+		memcpy(&bandwidth->cmp, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_TYPE:
+		memcpy(&bandwidth->type, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_CHECKTYPE:
+		memcpy(&bandwidth->check_type, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_BWCUTOFF:
+		memcpy(&bandwidth->bandwidth_cutoff, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_CURRENTBW:
+		memcpy(&bandwidth->current_bandwidth, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_SUBNET:
+		bandwidth->subnet = strdup(data);
+		if (!bandwidth->subnet)
+			return -1;
+		break;
+	case NFTNL_EXPR_BANDWIDTH_SUBNET6:
+		bandwidth->subnet6 = strdup(data);
+		if (!bandwidth->subnet6)
+			return -1;
+		break;
+	case NFTNL_EXPR_BANDWIDTH_RSTINTVL:
+		memcpy(&bandwidth->reset_interval, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST:
+		memcpy(&bandwidth->reset_is_constant_interval, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_RSTTIME:
+		memcpy(&bandwidth->reset_time, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE:
+		memcpy(&bandwidth->num_intervals_to_save, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_NEXTRESET:
+		memcpy(&bandwidth->next_reset, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_PREVRESET:
+		memcpy(&bandwidth->prev_reset, data, data_len);
+		break;
+	case NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME:
+		memcpy(&bandwidth->last_backup_time, data, data_len);
+		break;
+    case NFTNL_EXPR_BANDWIDTH_MINUTESWEST:
+		memcpy(&bandwidth->minutes_west, data, data_len);
+		break;
+	}
+	return 0;
+}
+
+static const void *
+nftnl_expr_bandwidth_get(const struct nftnl_expr *e, uint16_t type,
+		      uint32_t *data_len)
+{
+	struct nftnl_expr_bandwidth *bandwidth = nftnl_expr_data(e);
+
+	switch(type) {
+	case NFTNL_EXPR_BANDWIDTH_ID:
+		*data_len = strlen(bandwidth->id)+1;
+		return bandwidth->id;
+	case NFTNL_EXPR_BANDWIDTH_CMP:
+		*data_len = sizeof(uint8_t);
+		return &bandwidth->cmp;
+	case NFTNL_EXPR_BANDWIDTH_TYPE:
+		*data_len = sizeof(uint8_t);
+		return &bandwidth->type;
+	case NFTNL_EXPR_BANDWIDTH_CHECKTYPE:
+		*data_len = sizeof(uint8_t);
+		return &bandwidth->check_type;
+	case NFTNL_EXPR_BANDWIDTH_BWCUTOFF:
+		*data_len = sizeof(uint64_t);
+		return &bandwidth->bandwidth_cutoff;
+	case NFTNL_EXPR_BANDWIDTH_CURRENTBW:
+		*data_len = sizeof(uint64_t);
+		return &bandwidth->current_bandwidth;
+	case NFTNL_EXPR_BANDWIDTH_SUBNET:
+		*data_len = strlen(bandwidth->subnet)+1;
+		return bandwidth->subnet;
+	case NFTNL_EXPR_BANDWIDTH_SUBNET6:
+		*data_len = strlen(bandwidth->subnet6)+1;
+		return bandwidth->subnet6;
+	case NFTNL_EXPR_BANDWIDTH_RSTINTVL:
+		*data_len = sizeof(uint64_t);
+		return &bandwidth->reset_interval;
+	case NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST:
+		*data_len = sizeof(uint8_t);
+		return &bandwidth->reset_is_constant_interval;
+	case NFTNL_EXPR_BANDWIDTH_RSTTIME:
+		*data_len = sizeof(uint64_t);
+		return &bandwidth->reset_time;
+	case NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE:
+		*data_len = sizeof(uint32_t);
+		return &bandwidth->num_intervals_to_save;
+	case NFTNL_EXPR_BANDWIDTH_NEXTRESET:
+		*data_len = sizeof(uint64_t);
+		return &bandwidth->next_reset;
+	case NFTNL_EXPR_BANDWIDTH_PREVRESET:
+		*data_len = sizeof(uint64_t);
+		return &bandwidth->prev_reset;
+	case NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME:
+		*data_len = sizeof(uint64_t);
+		return &bandwidth->last_backup_time;
+    case NFTNL_EXPR_BANDWIDTH_MINUTESWEST:
+		*data_len = sizeof(uint32_t);
+		return &bandwidth->minutes_west;
+	}
+	return NULL;
+}
+
+static int nftnl_expr_bandwidth_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, NFTA_BANDWIDTH_MAX) < 0)
+		return MNL_CB_OK;
+
+	switch(type) {
+	case NFTNL_EXPR_BANDWIDTH_CMP:
+	case NFTNL_EXPR_BANDWIDTH_TYPE:
+	case NFTNL_EXPR_BANDWIDTH_CHECKTYPE:
+	case NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST:
+		if (mnl_attr_validate(attr, MNL_TYPE_U8) < 0)
+			abi_breakage();
+		break;
+	case NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE:
+	case NFTNL_EXPR_BANDWIDTH_MINUTESWEST:
+		if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0)
+			abi_breakage();
+		break;
+	case NFTNL_EXPR_BANDWIDTH_RSTINTVL:
+	case NFTNL_EXPR_BANDWIDTH_BWCUTOFF:
+	case NFTNL_EXPR_BANDWIDTH_CURRENTBW:
+   case NFTNL_EXPR_BANDWIDTH_RSTTIME:
+   case NFTNL_EXPR_BANDWIDTH_NEXTRESET:
+   case NFTNL_EXPR_BANDWIDTH_PREVRESET:
+	case NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME:
+		if (mnl_attr_validate(attr, MNL_TYPE_U64) < 0)
+			abi_breakage();
+		break;
+	case NFTNL_EXPR_BANDWIDTH_ID:
+	case NFTNL_EXPR_BANDWIDTH_SUBNET:
+	case NFTNL_EXPR_BANDWIDTH_SUBNET6:
+		if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0)
+			abi_breakage();
+		break;
+	}
+
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static void
+nftnl_expr_bandwidth_build(struct nlmsghdr *nlh, const struct nftnl_expr *e)
+{
+	struct nftnl_expr_bandwidth *bandwidth = nftnl_expr_data(e);
+	uint32_t minuteswest = 0;
+
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_ID))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_BANDWIDTH_ID, bandwidth->id);
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_CMP))
+		mnl_attr_put_u8(nlh, NFTNL_EXPR_BANDWIDTH_CMP, bandwidth->cmp);
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_TYPE))
+		mnl_attr_put_u8(nlh, NFTNL_EXPR_BANDWIDTH_TYPE, bandwidth->type);
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_CHECKTYPE))
+		mnl_attr_put_u8(nlh, NFTNL_EXPR_BANDWIDTH_CHECKTYPE, bandwidth->check_type);
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_BWCUTOFF))
+		mnl_attr_put_u64(nlh, NFTNL_EXPR_BANDWIDTH_BWCUTOFF, htobe64(bandwidth->bandwidth_cutoff));
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_CURRENTBW))
+		mnl_attr_put_u64(nlh, NFTNL_EXPR_BANDWIDTH_CURRENTBW, htobe64(bandwidth->current_bandwidth));
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_SUBNET))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_BANDWIDTH_SUBNET, bandwidth->subnet);
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_SUBNET6))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_BANDWIDTH_SUBNET6, bandwidth->subnet6);
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_RSTINTVL))
+		mnl_attr_put_u64(nlh, NFTNL_EXPR_BANDWIDTH_RSTINTVL, htobe64(bandwidth->reset_interval));
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST))
+		mnl_attr_put_u8(nlh, NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST, bandwidth->reset_is_constant_interval);
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_RSTTIME))
+		mnl_attr_put_u64(nlh, NFTNL_EXPR_BANDWIDTH_RSTTIME, htobe64(bandwidth->reset_time));
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE))
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE, htonl(bandwidth->num_intervals_to_save));
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_NEXTRESET))
+		mnl_attr_put_u64(nlh, NFTNL_EXPR_BANDWIDTH_NEXTRESET, htobe64(bandwidth->next_reset));
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_PREVRESET))
+		mnl_attr_put_u64(nlh, NFTNL_EXPR_BANDWIDTH_PREVRESET, htobe64(bandwidth->prev_reset));
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME))
+		mnl_attr_put_u64(nlh, NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME, htobe64(bandwidth->last_backup_time));
+
+	set_kernel_timezone();
+	minuteswest = get_minutes_west();
+
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_MINUTESWEST))
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_BANDWIDTH_MINUTESWEST, htonl(minuteswest));
+}
+
+static int
+nftnl_expr_bandwidth_parse(struct nftnl_expr *e, struct nlattr *attr)
+{
+	struct nftnl_expr_bandwidth *bandwidth = nftnl_expr_data(e);
+	struct nlattr *tb[NFTA_BANDWIDTH_MAX+1] = {};
+
+	if (mnl_attr_parse_nested(attr, nftnl_expr_bandwidth_cb, tb) < 0)
+		return -1;
+
+	if (tb[NFTNL_EXPR_BANDWIDTH_ID]) {
+		if (bandwidth->id)
+			xfree(bandwidth->id);
+
+		bandwidth->id = strdup(mnl_attr_get_str(tb[NFTNL_EXPR_BANDWIDTH_ID]));
+		if (!bandwidth->id)
+			return -1;
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_ID);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_CMP]) {
+		bandwidth->cmp = mnl_attr_get_u8(tb[NFTNL_EXPR_BANDWIDTH_CMP]);
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_CMP);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_TYPE]) {
+		bandwidth->type = mnl_attr_get_u8(tb[NFTNL_EXPR_BANDWIDTH_TYPE]);
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_TYPE);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_CHECKTYPE]) {
+		bandwidth->check_type = mnl_attr_get_u8(tb[NFTNL_EXPR_BANDWIDTH_CHECKTYPE]);
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_CHECKTYPE);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_BWCUTOFF]) {
+		bandwidth->bandwidth_cutoff = be64toh(mnl_attr_get_u64(tb[NFTNL_EXPR_BANDWIDTH_BWCUTOFF]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_BWCUTOFF);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_CURRENTBW]) {
+		bandwidth->current_bandwidth = be64toh(mnl_attr_get_u64(tb[NFTNL_EXPR_BANDWIDTH_CURRENTBW]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_CURRENTBW);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_SUBNET]) {
+		if (bandwidth->subnet)
+			xfree(bandwidth->subnet);
+
+		bandwidth->subnet = strdup(mnl_attr_get_str(tb[NFTNL_EXPR_BANDWIDTH_SUBNET]));
+		if (!bandwidth->subnet)
+			return -1;
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_SUBNET);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_SUBNET6]) {
+		if (bandwidth->subnet6)
+			xfree(bandwidth->subnet6);
+
+		bandwidth->subnet6 = strdup(mnl_attr_get_str(tb[NFTNL_EXPR_BANDWIDTH_SUBNET6]));
+		if (!bandwidth->subnet6)
+			return -1;
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_SUBNET6);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_RSTINTVL]) {
+		bandwidth->reset_interval = be64toh(mnl_attr_get_u64(tb[NFTNL_EXPR_BANDWIDTH_RSTINTVL]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_RSTINTVL);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST]) {
+		bandwidth->reset_is_constant_interval = mnl_attr_get_u8(tb[NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST]);
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_RSTTIME]) {
+		bandwidth->reset_time = be64toh(mnl_attr_get_u64(tb[NFTNL_EXPR_BANDWIDTH_RSTTIME]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_RSTTIME);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE]) {
+		bandwidth->num_intervals_to_save = ntohl(mnl_attr_get_u32(tb[NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_NEXTRESET]) {
+		bandwidth->next_reset = be64toh(mnl_attr_get_u64(tb[NFTNL_EXPR_BANDWIDTH_NEXTRESET]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_NEXTRESET);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_PREVRESET]) {
+		bandwidth->prev_reset = be64toh(mnl_attr_get_u64(tb[NFTNL_EXPR_BANDWIDTH_PREVRESET]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_PREVRESET);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME]) {
+		bandwidth->last_backup_time = be64toh(mnl_attr_get_u64(tb[NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME);
+	}
+	if (tb[NFTNL_EXPR_BANDWIDTH_MINUTESWEST]) {
+		bandwidth->minutes_west = ntohl(mnl_attr_get_u32(tb[NFTNL_EXPR_BANDWIDTH_MINUTESWEST]));
+		e->flags |= (1 << NFTNL_EXPR_BANDWIDTH_MINUTESWEST);
+	}
+
+	return 0;
+}
+
+static int
+nftnl_expr_bandwidth_snprintf(char *buf, size_t len,
+			   uint32_t flags, const struct nftnl_expr *e)
+{
+	struct nftnl_expr_bandwidth *bandwidth = nftnl_expr_data(e);
+	int ret, offset = 0, remain = len;
+	time_t now;
+	int minuteswest = 0;
+
+   time(&now);
+	if(e->flags & (1 << NFTNL_EXPR_BANDWIDTH_MINUTESWEST)) {
+		minuteswest = bandwidth->minutes_west;
+	}
+	now = now - (minuteswest*60);
+
+	if(e->flags & (1 << NFTNL_EXPR_BANDWIDTH_CMP) && e->flags & (1 << NFTNL_EXPR_BANDWIDTH_CHECKTYPE)) {
+		if(bandwidth->cmp == NFT_BANDWIDTH_CMP_CHECK && bandwidth->check_type != 0)
+		{
+			ret = snprintf(buf + offset, remain, "%s ", (bandwidth->check_type == NFT_BANDWIDTH_CHECKTYPE_NOSWAP ? "bcheck" : "bcheck-with-src-dst-swap"));
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+	}
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_ID)) {
+		ret = snprintf(buf + offset, remain, "id %s ", bandwidth->id);
+		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+	}
+	if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_CMP) && bandwidth->cmp != NFT_BANDWIDTH_CMP_CHECK) {
+		if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_TYPE) && bandwidth->type != 0) {
+			if(bandwidth->type == NFT_BANDWIDTH_TYPE_COMBINED)
+				ret = snprintf(buf + offset, remain, "type combined ");
+			else if(bandwidth->type == NFT_BANDWIDTH_TYPE_INDIVIDUALSRC)
+				ret = snprintf(buf + offset, remain, "type individual-src ");
+			else if(bandwidth->type == NFT_BANDWIDTH_TYPE_INDIVIDUALDST)
+				ret = snprintf(buf + offset, remain, "type individual-dst ");
+			else if(bandwidth->type == NFT_BANDWIDTH_TYPE_INDIVIDUALLOCAL)
+				ret = snprintf(buf + offset, remain, "type individual-local ");
+			else if(bandwidth->type == NFT_BANDWIDTH_TYPE_INDIVIDUALREMOTE)
+				ret = snprintf(buf + offset, remain, "type individual-remote ");
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+
+		if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_SUBNET) && strlen(bandwidth->subnet) > 0) {
+			ret = snprintf(buf + offset, remain, "subnet %s ", bandwidth->subnet);
+		}
+		if (e->flags & (1 << NFTNL_EXPR_BANDWIDTH_SUBNET6) && strlen(bandwidth->subnet6) > 0) {
+			ret = snprintf(buf + offset, remain, "subnet6 %s ", bandwidth->subnet6);
+		}
+
+		if(e->flags & (1 << NFTNL_EXPR_BANDWIDTH_BWCUTOFF) && (bandwidth->cmp == NFT_BANDWIDTH_CMP_LT || bandwidth->cmp == NFT_BANDWIDTH_CMP_GT))
+		{
+			ret = snprintf(buf + offset, remain, "%s-than %lu ", (bandwidth->cmp == NFT_BANDWIDTH_CMP_LT ? "less" : "greater"), bandwidth->bandwidth_cutoff);
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+
+		if(e->flags & (1 << NFTNL_EXPR_BANDWIDTH_TYPE) &&
+			e->flags & (1 << NFTNL_EXPR_BANDWIDTH_RSTINTVL) &&
+			e->flags & (1 << NFTNL_EXPR_BANDWIDTH_NEXTRESET) &&
+			e->flags & (1 << NFTNL_EXPR_BANDWIDTH_CURRENTBW) && bandwidth->type == NFT_BANDWIDTH_TYPE_COMBINED)
+		{
+			if(bandwidth->reset_interval != NFT_BANDWIDTH_RSTINTVL_NEVER && bandwidth->next_reset != 0 && bandwidth->next_reset < now)
+				ret = snprintf(buf + offset, remain, "current-bandwidth 0 ");
+			else
+				ret = snprintf(buf + offset, remain, "current-bandwidth %lu ", bandwidth->current_bandwidth);
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+
+		if(e->flags & (1 << NFTNL_EXPR_BANDWIDTH_RSTINTVL))
+		{
+			if(e->flags & (1 << NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST) && bandwidth->reset_is_constant_interval)
+			{
+				ret = snprintf(buf + offset, remain, "reset-interval %lu ", bandwidth->reset_interval);
+				SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+			}
+			else
+			{
+				if(bandwidth->reset_interval == NFT_BANDWIDTH_RSTINTVL_MINUTE)
+					ret = snprintf(buf + offset, remain, "reset-interval minute ");
+				else if(bandwidth->reset_interval == NFT_BANDWIDTH_RSTINTVL_HOUR)
+					ret = snprintf(buf + offset, remain, "reset-interval hour ");
+				else if(bandwidth->reset_interval == NFT_BANDWIDTH_RSTINTVL_DAY)
+					ret = snprintf(buf + offset, remain, "reset-interval day ");
+				else if(bandwidth->reset_interval == NFT_BANDWIDTH_RSTINTVL_WEEK)
+					ret = snprintf(buf + offset, remain, "reset-interval week ");
+				else if(bandwidth->reset_interval == NFT_BANDWIDTH_RSTINTVL_MONTH)
+					ret = snprintf(buf + offset, remain, "reset-interval month ");
+				SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+			}
+		}
+
+		if(e->flags & (1 << NFTNL_EXPR_BANDWIDTH_RSTTIME) && bandwidth->reset_time > 0)
+		{
+			ret = snprintf(buf + offset, remain, "reset-time %lu ", bandwidth->reset_time);
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+
+		if(e->flags & (1 << NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE) && bandwidth->num_intervals_to_save > 0)
+		{
+			ret = snprintf(buf + offset, remain, "num-intervals-to-save %u ", bandwidth->num_intervals_to_save);
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+	}
+
+	return offset;
+}
+
+static void nftnl_expr_bandwidth_free(const struct nftnl_expr *e)
+{
+	struct nftnl_expr_bandwidth *bandwidth = nftnl_expr_data(e);
+
+	xfree(bandwidth->id);
+	xfree(bandwidth->subnet);
+	xfree(bandwidth->subnet6);
+}
+
+struct expr_ops expr_ops_bandwidth = {
+	.name		= "bandwidth",
+	.alloc_len	= sizeof(struct nftnl_expr_bandwidth),
+	.nftnl_max_attr	= NFTA_BANDWIDTH_MAX,
+	.free		= nftnl_expr_bandwidth_free,
+	.set		= nftnl_expr_bandwidth_set,
+	.get		= nftnl_expr_bandwidth_get,
+	.parse		= nftnl_expr_bandwidth_parse,
+	.build		= nftnl_expr_bandwidth_build,
+	.output	= nftnl_expr_bandwidth_snprintf,
+};
+
+int get_minutes_west(void)
+{
+	time_t now;
+	struct tm* utc_info;
+	struct tm* tz_info;
+	int utc_day;
+	int utc_hour;
+	int utc_minute;
+	int tz_day;
+	int tz_hour;
+	int tz_minute;
+	int minuteswest;
+
+	time(&now);
+	utc_info = gmtime(&now);
+	utc_day = utc_info->tm_mday;
+	utc_hour = utc_info->tm_hour;
+	utc_minute = utc_info->tm_min;
+	tz_info = localtime(&now);
+	tz_day = tz_info->tm_mday;
+	tz_hour = tz_info->tm_hour;
+	tz_minute = tz_info->tm_min;
+
+	utc_day = utc_day < tz_day  - 1 ? tz_day  + 1 : utc_day;
+	tz_day =  tz_day  < utc_day - 1 ? utc_day + 1 : tz_day;
+
+	minuteswest = (24*60*utc_day + 60*utc_hour + utc_minute) - (24*60*tz_day + 60*tz_hour + tz_minute) ;
+
+	return minuteswest;
+}
+
+#ifndef SYS_settimeofday
+# ifdef __NR_settimeofday
+#  define SYS_settimeofday	__NR_settimeofday
+# elif defined(__NR_settimeofday_time32)
+#  define SYS_settimeofday	__NR_settimeofday_time32
+# endif
+#endif
+
+#ifndef SYS_gettimeofday
+# ifdef __NR_gettimeofday
+#  define SYS_gettimeofday	__NR_gettimeofday
+# elif defined(__NR_gettimeofday_time32)
+#  define SYS_gettimeofday	__NR_gettimeofday_time32
+# endif
+#endif
+
+void set_kernel_timezone(void)
+{
+	struct timeval tv;
+	struct timezone old_tz;
+	struct timezone new_tz;
+
+	new_tz.tz_minuteswest = get_minutes_west();
+	new_tz.tz_dsttime = 0;
+
+	/* Get tv to pass to settimeofday(2) to be sure we avoid hour-sized warp */
+	/* (see gettimeofday(2) man page, or /usr/src/linux/kernel/time.c) */
+#ifdef SYS_gettimeofday
+	errno = 0;
+	syscall(SYS_gettimeofday, &tv, &old_tz);
+#else
+	gettimeofday(&tv, &new_tz);
+#endif
+	//printf("set_kernel_timezone: old minuteswest: %d, new minuteswest: %d\n", old_tz.tz_minuteswest, new_tz.tz_minuteswest);
+	/* set timezone */
+#ifdef SYS_settimeofday
+	errno = 0;
+	syscall(SYS_settimeofday, NULL, &new_tz);
+#else
+	settimeofday(NULL, &new_tz);
+#endif
+}
\ 文件末尾没有换行符
--- /dev/null	2025-12-08 14:44:46.335265239 +0800
+++ libnftnl.new/src/expr/weburl.c	2025-12-08 20:00:43.815783541 +0800
@@ -0,0 +1,185 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/netfilter/nf_tables.h>
+#include <linux/netfilter/weburl.h>
+
+#include <time.h>
+#include <sys/time.h>
+
+#include "internal.h"
+#include <libmnl/libmnl.h>
+#include <libnftnl/expr.h>
+#include <libnftnl/rule.h>
+
+struct nftnl_expr_weburl {
+	uint32_t		flags;
+	const char		*match;
+};
+
+static int nftnl_expr_weburl_set(struct nftnl_expr *e, uint16_t type,
+				 const void *data, uint32_t data_len)
+{
+	struct nftnl_expr_weburl *weburl = nftnl_expr_data(e);
+	switch(type){
+	case NFTNL_EXPR_WEBURL_FLAGS:
+		memcpy(&weburl->flags, data, data_len);
+		break;
+	case NFTNL_EXPR_WEBURL_MATCH:
+		weburl->match = strdup(data);
+		if (!weburl->match)
+			return -1;
+		break;
+	}
+	return 0;
+}
+
+static const void *
+nftnl_expr_weburl_get(const struct nftnl_expr *e, uint16_t type,
+		      uint32_t *data_len)
+{
+	struct nftnl_expr_weburl *weburl = nftnl_expr_data(e);
+
+	switch(type) {
+	case NFTNL_EXPR_WEBURL_FLAGS:
+		*data_len = sizeof(uint32_t);
+		return &weburl->flags;
+	case NFTNL_EXPR_WEBURL_MATCH:
+		*data_len = strlen(weburl->match)+1;
+		return weburl->match;
+	}
+	return NULL;
+}
+
+static int nftnl_expr_weburl_cb(const struct nlattr *attr, void *data)
+{
+	const struct nlattr **tb = data;
+	int type = mnl_attr_get_type(attr);
+
+	if (mnl_attr_type_valid(attr, NFTA_WEBURL_MAX) < 0)
+		return MNL_CB_OK;
+
+	switch(type) {
+	case NFTNL_EXPR_WEBURL_FLAGS:
+		if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0)
+			abi_breakage();
+		break;
+	case NFTNL_EXPR_WEBURL_MATCH:
+		if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0)
+			abi_breakage();
+		break;
+	}
+
+	tb[type] = attr;
+	return MNL_CB_OK;
+}
+
+static void
+nftnl_expr_weburl_build(struct nlmsghdr *nlh, const struct nftnl_expr *e)
+{
+	struct nftnl_expr_weburl *weburl = nftnl_expr_data(e);
+
+	if (e->flags & (1 << NFTNL_EXPR_WEBURL_FLAGS))
+		mnl_attr_put_u32(nlh, NFTNL_EXPR_WEBURL_FLAGS, htonl(weburl->flags));
+	if (e->flags & (1 << NFTNL_EXPR_WEBURL_MATCH))
+		mnl_attr_put_strz(nlh, NFTNL_EXPR_WEBURL_MATCH, weburl->match);
+}
+
+static int
+nftnl_expr_weburl_parse(struct nftnl_expr *e, struct nlattr *attr)
+{
+	struct nftnl_expr_weburl *weburl = nftnl_expr_data(e);
+	struct nlattr *tb[NFTA_WEBURL_MAX+1] = {};
+
+	if (mnl_attr_parse_nested(attr, nftnl_expr_weburl_cb, tb) < 0)
+		return -1;
+
+	if (tb[NFTNL_EXPR_WEBURL_FLAGS]) {
+		weburl->flags = ntohl(mnl_attr_get_u32(tb[NFTNL_EXPR_WEBURL_FLAGS]));
+		e->flags |= (1 << NFTNL_EXPR_WEBURL_FLAGS);
+	}
+	if (tb[NFTNL_EXPR_WEBURL_MATCH]) {
+		if (weburl->match)
+			xfree(weburl->match);
+
+		weburl->match = strdup(mnl_attr_get_str(tb[NFTNL_EXPR_WEBURL_MATCH]));
+		if (!weburl->match)
+			return -1;
+		e->flags |= (1 << NFTNL_EXPR_WEBURL_MATCH);
+	}
+
+	return 0;
+}
+
+static int
+nftnl_expr_weburl_snprintf(char *buf, size_t len,
+			   uint32_t flags, const struct nftnl_expr *e)
+{
+	struct nftnl_expr_weburl *weburl = nftnl_expr_data(e);
+	int ret, offset = 0, remain = len;
+
+	if (e->flags & (1 << NFTNL_EXPR_WEBURL_FLAGS)) {
+		bool inv = weburl->flags & NFT_WEBURL_F_INV;
+		if (e->flags & (1 << NFTNL_EXPR_WEBURL_FLAGS)) {
+			if(weburl->flags & NFT_WEBURL_F_MP_DOMAINONLY)
+			{
+				ret = snprintf(buf + offset, remain, "domain-only ");
+				SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+			}
+			else if(weburl->flags & NFT_WEBURL_F_MP_PATHONLY)
+			{
+				ret = snprintf(buf + offset, remain, "path-only ");
+				SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+			}
+		}
+
+		if(weburl->flags & NFT_WEBURL_F_MT_CONTAINS)
+		{
+			ret = snprintf(buf + offset, remain, "contains ");
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+		else if(weburl->flags & NFT_WEBURL_F_MT_CONTAINSREGEX)
+		{
+			ret = snprintf(buf + offset, remain, "contains-regex ");
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+		else if(weburl->flags & NFT_WEBURL_F_MT_MATCHESEXACTLY)
+		{
+			ret = snprintf(buf + offset, remain, "matches-exactly ");
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+
+		if(inv)
+		{
+			ret = snprintf(buf + offset, remain, "!= ");
+			SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+		}
+	}
+	if (e->flags & (1 << NFTNL_EXPR_WEBURL_MATCH)) {
+		ret = snprintf(buf + offset, remain, "%s", weburl->match);
+		SNPRINTF_BUFFER_SIZE(ret, remain, offset);
+	}
+
+	return offset;
+}
+
+static void nftnl_expr_weburl_free(const struct nftnl_expr *e)
+{
+	struct nftnl_expr_weburl *weburl = nftnl_expr_data(e);
+
+	xfree(weburl->match);
+}
+
+struct expr_ops expr_ops_weburl = {
+	.name		= "weburl",
+	.alloc_len	= sizeof(struct nftnl_expr_weburl),
+	.nftnl_max_attr	= NFTA_WEBURL_MAX,
+	.free		= nftnl_expr_weburl_free,
+	.set		= nftnl_expr_weburl_set,
+	.get		= nftnl_expr_weburl_get,
+	.parse		= nftnl_expr_weburl_parse,
+	.build		= nftnl_expr_weburl_build,
+	.output	= nftnl_expr_weburl_snprintf,
+};
\ 文件末尾没有换行符
--- libnftnl.orig/src/Makefile.in	2025-08-06 15:55:28.473569524 +0800
+++ libnftnl.new/src/Makefile.in	2025-12-08 20:00:47.528690564 +0800
@@ -137,6 +137,10 @@
 	gen.lo table.lo trace.lo chain.lo object.lo rule.lo set.lo \
 	set_elem.lo str_array.lo ruleset.lo udata.lo expr.lo \
 	expr_ops.lo expr/bitwise.lo expr/byteorder.lo expr/cmp.lo \
+	expr/bandwidth.lo \
+	expr/timerange.lo \
+	expr/webmon.lo \
+	expr/weburl.lo \
 	expr/range.lo expr/connlimit.lo expr/counter.lo expr/ct.lo \
 	expr/data_reg.lo expr/dup.lo expr/exthdr.lo \
 	expr/flow_offload.lo expr/fib.lo expr/fwd.lo expr/last.lo \
@@ -180,6 +184,10 @@
 	./$(DEPDIR)/set.Plo ./$(DEPDIR)/set_elem.Plo \
 	./$(DEPDIR)/str_array.Plo ./$(DEPDIR)/table.Plo \
 	./$(DEPDIR)/trace.Plo ./$(DEPDIR)/udata.Plo \
+	expr/$(DEPDIR)/bandwidth.Plo \
+	expr/$(DEPDIR)/timerange.Plo \
+	expr/$(DEPDIR)/webmon.Plo \
+	expr/$(DEPDIR)/weburl.Plo \
 	./$(DEPDIR)/utils.Plo expr/$(DEPDIR)/bitwise.Plo \
 	expr/$(DEPDIR)/byteorder.Plo expr/$(DEPDIR)/cmp.Plo \
 	expr/$(DEPDIR)/connlimit.Plo expr/$(DEPDIR)/counter.Plo \
@@ -409,6 +417,10 @@
 
 libnftnl_la_SOURCES = utils.c		\
 		      batch.c		\
+	      expr/bandwidth.c \
+	      expr/timerange.c \
+	      expr/webmon.c \
+	      expr/weburl.c \
 		      flowtable.c	\
 		      common.c		\
 		      gen.c		\
@@ -591,6 +603,10 @@
 expr/synproxy.lo: expr/$(am__dirstamp) expr/$(DEPDIR)/$(am__dirstamp)
 expr/osf.lo: expr/$(am__dirstamp) expr/$(DEPDIR)/$(am__dirstamp)
 expr/xfrm.lo: expr/$(am__dirstamp) expr/$(DEPDIR)/$(am__dirstamp)
+expr/bandwidth.lo: expr/$(am__dirstamp) expr/$(DEPDIR)/$(am__dirstamp)
+expr/timerange.lo: expr/$(am__dirstamp) expr/$(DEPDIR)/$(am__dirstamp)
+expr/webmon.lo: expr/$(am__dirstamp) expr/$(DEPDIR)/$(am__dirstamp)
+expr/weburl.lo: expr/$(am__dirstamp) expr/$(DEPDIR)/$(am__dirstamp)
 obj/$(am__dirstamp):
 	@$(MKDIR_P) obj
 	@: > obj/$(am__dirstamp)
@@ -677,6 +693,10 @@
 @AMDEP_TRUE@@am__include@ @am__quote@expr/$(DEPDIR)/tproxy.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@expr/$(DEPDIR)/tunnel.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@expr/$(DEPDIR)/xfrm.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@expr/$(DEPDIR)/bandwidth.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@expr/$(DEPDIR)/timerange.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@expr/$(DEPDIR)/webmon.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@expr/$(DEPDIR)/weburl.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@obj/$(DEPDIR)/counter.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@obj/$(DEPDIR)/ct_expect.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@obj/$(DEPDIR)/ct_helper.Plo@am__quote@ # am--include-marker
@@ -857,6 +877,10 @@
 
 distclean: distclean-am
 		-rm -f ./$(DEPDIR)/batch.Plo
+	-rm -f expr/$(DEPDIR)/bandwidth.Plo
+	-rm -f expr/$(DEPDIR)/timerange.Plo
+	-rm -f expr/$(DEPDIR)/webmon.Plo
+	-rm -f expr/$(DEPDIR)/weburl.Plo
 	-rm -f ./$(DEPDIR)/chain.Plo
 	-rm -f ./$(DEPDIR)/common.Plo
 	-rm -f ./$(DEPDIR)/expr.Plo
@@ -968,6 +992,10 @@
 
 maintainer-clean: maintainer-clean-am
 		-rm -f ./$(DEPDIR)/batch.Plo
+	-rm -f expr/$(DEPDIR)/bandwidth.Plo
+	-rm -f expr/$(DEPDIR)/timerange.Plo
+	-rm -f expr/$(DEPDIR)/webmon.Plo
+	-rm -f expr/$(DEPDIR)/weburl.Plo
 	-rm -f ./$(DEPDIR)/chain.Plo
 	-rm -f ./$(DEPDIR)/common.Plo
 	-rm -f ./$(DEPDIR)/expr.Plo
--- libnftnl.orig/src/expr_ops.c	2025-12-08 20:00:42.574179697 +0800
+++ libnftnl.new/src/expr_ops.c	2025-12-08 20:00:47.372688394 +0800
@@ -31,6 +31,10 @@
 extern struct expr_ops expr_ops_range;
 extern struct expr_ops expr_ops_redir;
 extern struct expr_ops expr_ops_reject;
+extern struct expr_ops expr_ops_bandwidth;
+extern struct expr_ops expr_ops_timerange;
+extern struct expr_ops expr_ops_webmon;
+extern struct expr_ops expr_ops_weburl;
 extern struct expr_ops expr_ops_rt;
 extern struct expr_ops expr_ops_queue;
 extern struct expr_ops expr_ops_quota;
@@ -77,6 +81,10 @@
 	&expr_ops_range,
 	&expr_ops_redir,
 	&expr_ops_reject,
+	&expr_ops_bandwidth,
+	&expr_ops_timerange,
+	&expr_ops_webmon,
+	&expr_ops_weburl,
 	&expr_ops_rt,
 	&expr_ops_queue,
 	&expr_ops_quota,
--- /dev/null	2025-12-08 14:44:46.335265239 +0800
+++ libnftnl.new/include/linux/netfilter/timerange.h	2025-12-08 20:00:46.067388713 +0800
@@ -0,0 +1,15 @@
+#ifndef _TIMERANGE_H
+#define _TIMERANGE_H
+
+enum nft_timerange_attributes {
+	NFTA_TIMERANGE_UNSPEC,
+	NFTA_TIMERANGE_FLAGS,
+	NFTA_TIMERANGE_HOURS,
+	NFTA_TIMERANGE_WEEKDAYS,
+	NFTA_TIMERANGE_WEEKLYRANGES,
+	__NFTA_TIMERANGE_MAX,
+};
+
+#define NFTA_TIMERANGE_MAX (__NFTA_TIMERANGE_MAX - 1)
+
+#endif /* _TIMERANGE_H */
\ 文件末尾没有换行符
--- /dev/null	2025-12-08 14:44:46.335265239 +0800
+++ libnftnl.new/include/linux/netfilter/webmon.h	2025-12-08 20:00:44.893360976 +0800
@@ -0,0 +1,24 @@
+#ifndef _WEBMON_H
+#define _WEBMON_H
+
+#define WEBMON_DOMAIN             16
+#define WEBMON_SEARCH             32
+#define WEBMON_SET              3064
+enum nft_timerange_attributes {
+	NFTA_WEBMON_UNSPEC,
+	NFTA_WEBMON_FLAGS,
+	NFTA_WEBMON_MAXDOMAINS,
+	NFTA_WEBMON_MAXSEARCHES,
+	NFTA_WEBMON_IPS,
+	NFTA_WEBMON_DOMAINLOADFILE,
+	NFTA_WEBMON_SEARCHLOADFILE,
+	NFTA_WEBMON_DOMAINLOADDATA,
+	NFTA_WEBMON_DOMAINLOADDATALEN,
+	NFTA_WEBMON_SEARCHLOADDATA,
+	NFTA_WEBMON_SEARCHLOADDATALEN,
+	__NFTA_WEBMON_MAX,
+};
+
+#define NFTA_WEBMON_MAX (__NFTA_WEBMON_MAX - 1)
+
+#endif /* _WEBMON_H */
\ 文件末尾没有换行符
--- libnftnl.orig/include/linux/netfilter/nf_tables.h	2025-12-08 20:00:42.573072097 +0800
+++ libnftnl.new/include/linux/netfilter/nf_tables.h	2025-12-08 20:00:47.431689214 +0800
@@ -1440,6 +1440,53 @@
 };
 #define NFTA_REJECT_MAX		(__NFTA_REJECT_MAX - 1)
 
+enum nft_bandwidth_cmp_types {
+	NFT_BANDWIDTH_CMP_MONITOR	= 74,
+	NFT_BANDWIDTH_CMP_LT		= 73,
+	NFT_BANDWIDTH_CMP_GT		= 72,
+	NFT_BANDWIDTH_CMP_CHECK		= 75,
+};
+enum nft_bandwidth_check_types {
+	NFT_BANDWIDTH_CHECKTYPE_NOSWAP	= 76,
+	NFT_BANDWIDTH_CHECKTYPE_SWAP	= 77,
+};
+enum nft_bandwidth_types {
+	NFT_BANDWIDTH_TYPE_COMBINED				= 90,
+	NFT_BANDWIDTH_TYPE_INDIVIDUALSRC		= 91,
+	NFT_BANDWIDTH_TYPE_INDIVIDUALDST		= 92,
+	NFT_BANDWIDTH_TYPE_INDIVIDUALLOCAL		= 93,
+	NFT_BANDWIDTH_TYPE_INDIVIDUALREMOTE		= 94,
+};
+enum nft_bandwidth_resetinterval_types {
+	NFT_BANDWIDTH_RSTINTVL_MINUTE	= 80,
+	NFT_BANDWIDTH_RSTINTVL_HOUR		= 81,
+	NFT_BANDWIDTH_RSTINTVL_DAY		= 82,
+	NFT_BANDWIDTH_RSTINTVL_WEEK		= 83,
+	NFT_BANDWIDTH_RSTINTVL_MONTH	= 84,
+	NFT_BANDWIDTH_RSTINTVL_NEVER	= 85,
+};
+
+enum nft_timerange_flags {
+	NFT_TIMERANGE_F_INV	= (1 << 0),
+};
+
+enum nft_webmon_flags {
+	NFT_WEBMON_F_EXCLUDE		= (1 << 0),
+	NFT_WEBMON_F_INCLUDE		= (1 << 1),
+	NFT_WEBMON_F_CLEARDOMAIN    = (1 << 2),
+	NFT_WEBMON_F_CLEARSEARCH    = (1 << 3),
+};
+
+enum nft_weburl_flags {
+	NFT_WEBURL_F_INV				= (1 << 0),
+	NFT_WEBURL_F_MT_CONTAINS		= (1 << 1),
+	NFT_WEBURL_F_MT_CONTAINSREGEX	= (1 << 2),
+	NFT_WEBURL_F_MT_MATCHESEXACTLY	= (1 << 3),
+	NFT_WEBURL_F_MP_ALL				= (1 << 4),
+	NFT_WEBURL_F_MP_DOMAINONLY		= (1 << 5),
+	NFT_WEBURL_F_MP_PATHONLY		= (1 << 6),
+};
+
 /**
  * enum nft_nat_types - nf_tables nat expression NAT types
  *
--- /dev/null	2025-12-08 14:44:46.335265239 +0800
+++ libnftnl.new/include/linux/netfilter/weburl.h	2025-12-08 20:00:43.714566718 +0800
@@ -0,0 +1,13 @@
+#ifndef _WEBURL_H
+#define _WEBURL_H
+
+enum nft_weburl_attributes {
+	NFTA_WEBURL_UNSPEC,
+	NFTA_WEBURL_FLAGS,
+	NFTA_WEBURL_MATCH,
+	__NFTA_WEBURL_MAX,
+};
+
+#define NFTA_WEBURL_MAX (__NFTA_WEBURL_MAX - 1)
+
+#endif /* _WEBURL_H */
\ 文件末尾没有换行符
--- /dev/null	2025-12-08 14:44:46.335265239 +0800
+++ libnftnl.new/include/linux/netfilter/bandwidth.h	2025-12-08 20:00:47.296362042 +0800
@@ -0,0 +1,28 @@
+#ifndef _BANDWIDTH_H
+#define _BANDWIDTH_H
+
+enum nft_bandwidth_attributes {
+	NFTA_BANDWIDTH_UNSPEC,
+	NFTA_BANDWIDTH_ID,
+	NFTA_BANDWIDTH_CMP,
+	NFTA_BANDWIDTH_TYPE,
+	NFTA_BANDWIDTH_CHECKTYPE,
+	NFTA_BANDWIDTH_BWCUTOFF,
+	NFTA_BANDWIDTH_CURRENTBW,
+	NFTA_BANDWIDTH_SUBNET,
+	NFTA_BANDWIDTH_SUBNET6,
+	NFTA_BANDWIDTH_RSTINTVL,
+	NFTA_BANDWIDTH_RSTINTVLCONST,
+	NFTA_BANDWIDTH_RSTTIME,
+	NFTA_BANDWIDTH_NUMINTVLSTOSAVE,
+	NFTA_BANDWIDTH_NEXTRESET,
+	NFTA_BANDWIDTH_PREVRESET,
+	NFTA_BANDWIDTH_LASTBACKUPTIME,
+	NFTA_BANDWIDTH_MINUTESWEST,
+	NFTA_BANDWIDTH_PAD,
+	__NFTA_BANDWIDTH_MAX,
+};
+
+#define NFTA_BANDWIDTH_MAX (__NFTA_BANDWIDTH_MAX - 1)
+
+#endif /* _BANDWIDTH_H */
\ 文件末尾没有换行符
--- libnftnl.orig/include/libnftnl/expr.h	2025-12-08 20:00:42.572426987 +0800
+++ libnftnl.new/include/libnftnl/expr.h	2025-12-08 20:00:47.276687058 +0800
@@ -48,6 +48,50 @@
 int nftnl_expr_fprintf(FILE *fp, const struct nftnl_expr *expr, uint32_t type, uint32_t flags);
 
 enum {
+	NFTNL_EXPR_BANDWIDTH_ID	= NFTNL_EXPR_BASE,
+	NFTNL_EXPR_BANDWIDTH_CMP,
+	NFTNL_EXPR_BANDWIDTH_TYPE,
+	NFTNL_EXPR_BANDWIDTH_CHECKTYPE,
+	NFTNL_EXPR_BANDWIDTH_BWCUTOFF,
+	NFTNL_EXPR_BANDWIDTH_CURRENTBW,
+	NFTNL_EXPR_BANDWIDTH_SUBNET,
+	NFTNL_EXPR_BANDWIDTH_SUBNET6,
+	NFTNL_EXPR_BANDWIDTH_RSTINTVL,
+	NFTNL_EXPR_BANDWIDTH_RSTINTVLCONST,
+	NFTNL_EXPR_BANDWIDTH_RSTTIME,
+	NFTNL_EXPR_BANDWIDTH_NUMINTVLSTOSAVE,
+	NFTNL_EXPR_BANDWIDTH_NEXTRESET,
+	NFTNL_EXPR_BANDWIDTH_PREVRESET,
+	NFTNL_EXPR_BANDWIDTH_LASTBACKUPTIME,
+	NFTNL_EXPR_BANDWIDTH_MINUTESWEST,
+};
+
+enum {
+	NFTNL_EXPR_TIMERANGE_FLAGS	= NFTNL_EXPR_BASE,
+	NFTNL_EXPR_TIMERANGE_HOURS,
+	NFTNL_EXPR_TIMERANGE_WEEKDAYS,
+	NFTNL_EXPR_TIMERANGE_WEEKLYRANGES,
+};
+
+enum {
+	NFTNL_EXPR_WEBMON_FLAGS	= NFTNL_EXPR_BASE,
+	NFTNL_EXPR_WEBMON_MAXDOMAINS,
+	NFTNL_EXPR_WEBMON_MAXSEARCHES,
+	NFTNL_EXPR_WEBMON_IPS,
+	NFTNL_EXPR_WEBMON_DOMAINLOADFILE,
+	NFTNL_EXPR_WEBMON_SEARCHLOADFILE,
+	NFTNL_EXPR_WEBMON_DOMAINLOADDATA,
+	NFTNL_EXPR_WEBMON_DOMAINLOADDATALEN,
+	NFTNL_EXPR_WEBMON_SEARCHLOADDATA,
+	NFTNL_EXPR_WEBMON_SEARCHLOADDATALEN,
+};
+
+enum {
+	NFTNL_EXPR_WEBURL_FLAGS	= NFTNL_EXPR_BASE,
+	NFTNL_EXPR_WEBURL_MATCH,
+};
+
+enum {
 	NFTNL_EXPR_PAYLOAD_DREG	= NFTNL_EXPR_BASE,
 	NFTNL_EXPR_PAYLOAD_BASE,
 	NFTNL_EXPR_PAYLOAD_OFFSET,

--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -22,6 +22,7 @@
 		      udata.c		\
 		      expr.c		\
 		      expr_ops.c	\
+			  expr/bandwidth.c	\
 		      expr/bitwise.c	\
 		      expr/byteorder.c	\
 		      expr/cmp.c	\
@@ -54,7 +55,10 @@
 		      expr/reject.c	\
 		      expr/rt.c		\
 		      expr/target.c	\
+		      expr/timerange.c	\
 		      expr/tunnel.c	\
+			  expr/webmon.c \
+			  expr/weburl.c \
 		      expr/masq.c	\
 		      expr/fullcone.c	\
 		      expr/redir.c	\